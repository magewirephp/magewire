<?php

declare(strict_types=1);

use Magento\Framework\Escaper;
use Magento\Framework\View\Element\Template;
use Magewirephp\Magewire\ViewModel\Magewire as MagewireViewModel;

/** @var Escaper $escaper */
/** @var Template $block */
/** @var MagewireViewModel $magewireViewModel */

$magewireViewModel = $block->getData('view_model');
$magewireFragment = $magewireViewModel->utils()->fragment();

/** @internal Do not modify to ensure Magewire continues to function correctly. */
?>
<?php $script = $magewireFragment->make()->script()->start() ?>
<script>
    document.addEventListener('magewire:init', event => {
        const { addons, utilities } = event.detail.magewire;

        Magewire.hook('commit', ({ component, commit, respond, succeed, fail }) => {
            const notify = function(text, title = null, options = {}, hooks = {}) {
                const parts = utilities.loader.parseText(text)

                const trySecondaryPart = parts => {
                    if (parts.length === 2 && parts[1].text) {
                        addons.notifier.create(parts[1].text, {
                            title: title ? title : (parts[1].title || null)
                        })
                    }
                }

                options = {
                    title: title ? title : (parts[0].title || null),

                    loader: {
                        active: true
                    },

                    ...options
                }

                <?php /* Backup possible 'onActivate' overwrite. */ ?>
                const activateHook = hooks.onActivate

                hooks = {
                    onActivate: async notification => {
                        if (typeof activateHook === 'function') {
                            await activateHook({ notification: notification });
                        }

                        return new Promise(resolve => {
                            succeed(({ snapshot, effect }) => {
                                trySecondaryPart(parts);
                                resolve(true);
                            });
                        });
                    },

                    ...hooks
                }

                parts[0]
                    ? addons.notifier.create(parts[0].text, options, hooks)
                    : succeed(({ snapshot, effect }) => trySecondaryPart(parts))
            }

            const expression = {
                update: (prop, value, loader) => {
                    // Define expressions in order of specificity (most specific first)
                    const expressions = [
                        // 1. MOST SPECIFIC: exact property:value match
                        `${prop}:${value}`,
                        // 2. parent:value
                        prop.includes('.') ? `${prop.substring(0, prop.lastIndexOf('.'))}:${value}` : null,
                        // 3. last segment with value
                        `${prop.split('.').pop()}:${value}`,
                        // 4. exact property name
                        prop,
                        // 5. parent property
                        prop.includes('.') ? prop.substring(0, prop.lastIndexOf('.')) : null,
                        // 6. LEAST SPECIFIC: last segment only
                        prop.split('.').pop(),
                    ].filter(expr => expr !== null);

                    // Find the first (most specific) matching expression
                    const matchedExpression = expressions.find(expr => {
                        const property = expr.includes(':') ? expr.split(':')[0] : expr;

                        if (typeof loader === 'boolean') {
                            return loader;
                        }
                        if (typeof loader === 'string') {
                            return true;
                        }
                        if (Array.isArray(loader)) {
                            return loader.includes(expr) || loader.includes(property);
                        }
                        if (typeof loader === 'object' && loader !== null) {
                            return expr in loader || property in loader;
                        }

                        return false;
                    });

                    // If no expression matches, return false
                    if (! matchedExpression) {
                        return false;
                    }

                    // Return the appropriate value based on loader type
                    if (typeof loader === 'boolean') {
                        return loader;
                    }
                    if (typeof loader === 'string') {
                        return loader;
                    }
                    if (Array.isArray(loader) || typeof loader === 'object') {
                        return loader[matchedExpression] ?? loader[matchedExpression.split(':')[0]] ?? loader;
                    }

                    return false;
                },

                call: (item, loader) => {
                    const method = item.method;

                    const expression = [
                        method,                                                 // exact method name
                        method.includes('.') ? method.substring(0, method.lastIndexOf('.')) : null, // parent method
                        method.split('.').pop(),                                // last segment only
                        '*',                                                    // wildcard match
                    ].filter(expr => expr !== null).filter(expr => {
                        const methodName = expr.includes(':') ? expr.split(':')[0] : expr;

                        if (typeof loader === 'boolean') {
                            return loader;
                        }
                        if (typeof loader === 'string') {
                            return true;
                        }

                        if (Array.isArray(loader)) {
                            return loader.includes(expr) || loader.includes(methodName) || methodName in loader;
                        }
                        if (typeof loader === 'object' && loader !== null) {
                            return methodName in loader || expr in loader;
                        }

                        return false;
                    })[0] || false;

                    if (! expression) {
                        return false;
                    }
                    if (typeof loader === 'boolean') {
                        return loader;
                    }
                    if (typeof loader === 'string') {
                        return loader;
                    }

                    if (Array.isArray(loader) || typeof loader === 'object') {
                        return loader[expression] ?? loader;
                    }

                    return false;
                }
            }

            if (component.effects.loader) {
                if (commit.calls.length !== 0) {
                    commit.calls.forEach(call => {
                        const notifications = expression.call(call, component.effects.loader[0]);

                        /**
                        protected $loader = [
                            'save' => 'Saving data...',
                            'delete' => 'Deleting item...',
                            'updateProfile' => 'Updating your profile...',
                            'user.save' => 'Saving user data...',

                            // Method with specific parameters
                            'save:{"draft":true}' => 'Saving as draft...',
                            'delete:{"force":true}' => 'Permanently deleting...',

                            // Parent method matching
                            'user' => 'Processing user action...',

                            // Last segment matching
                            'save' => 'Saving changes...',

                            // Wildcard
                            '*' => 'Processing request...',
                            '*:{"confirm":true}' => 'Confirming action...'
                         ];
                         */
                        if (typeof notifications === 'object') {
                            notifications.forEach(notification => notify(notification))
                        }
                    })
                }

                if (Object.values(commit.updates).length !== 0) {
                    for (let key in commit.updates) {
                        if (commit.updates.hasOwnProperty(key)) {
                            const previous = component.canonical[key]
                            const value = commit.updates[key]
                            const notifications = expression.update(key, value, component.effects.loader[0])

                            /**
                            protected $loader = [
                                // Exact property:value matches
                                'status:active' => 'Activating status...',
                                'user.role:admin' => 'Setting admin privileges...',

                                // Property names
                                'foo' => 'Processing foo...',
                                'user.name' => 'Updating user name...',

                                // Parent properties (for nested properties)
                                'user' => 'Updating user data...',
                                'profile' => 'Updating profile...',

                                // Last segment matching
                                'name' => 'Updating name field...',
                                'email' => 'Updating email...',

                                // Wildcard matches
                                '*' => 'Processing request...',
                                '*:true' => 'Enabling feature...',
                                '*:false' => 'Disabling feature...'
                             ];
                             */

                            if (typeof notifications === 'object') {
                                notifications.forEach(notification => notify(notification
                                    .replace(/{value}/g, value)
                                    .replace(/{previous_value}/g, previous)
                                ))
                            }
                        }
                    }
                }
            }
        })
    })
</script>
<?php $script->end() ?>
