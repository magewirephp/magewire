<?php

declare(strict_types=1);

use Magento\Framework\Escaper;
use Magento\Framework\View\Element\Template;
use Magewirephp\Magewire\ViewModel\Magewire as MagewireViewModel;

/** @var Escaper $escaper */
/** @var Template $block */
/** @var MagewireViewModel $magewireViewModel */

$magewireViewModel = $block->getData('view_model');
$magewireTemplate = $magewireViewModel->utils()->template();
$magewireFragment = $magewireViewModel->utils()->fragment();

/** @internal Do not modify to ensure Magewire continues to function correctly. */
?>
<?= $magewireTemplate->echoCodeComment('magewire notifier', false, 'AlpineJS') ?>
<?php $script = $magewireFragment->make()->script()->start() ?>
<script>
    function magewireNotifier() {
        'use strict';

        const notifier = Magewire.addons.notifier;

        return {
            get notifications() {
                return notifier.notifications;
            },

            <?php /* START: Only add those methods that should become CSP compatible. */ ?>
            terminate: function() {
                notifier.terminate(this.notification.id)
            },
            <?php /* END */?>

            bindings: {
                notification: {
                    item: {
                        root: function() {
                            return {
                                'x-on:click'() {
                                    notifier.terminate(this.notification.id);
                                },
                                'x-on:mouseenter'() {
                                    notifier.hold(this.notification.id);
                                },
                                'x-on:mouseleave'() {
                                    <?php /* Maybe at some point this should become .resume() when implemented. */ ?>
                                    notifier.cleanup(this.notification.id);
                                }
                            }
                        },

                        recover: function() {
                            return {
                                'x-bind:type'() {
                                    return 'button';
                                },
                                'x-show'() {
                                    return this.notification.recoverable === true;
                                },
                                async 'x-on:click'(event) {
                                    event.stopPropagation();

                                    this.notification.state = 'recovering';

                                    try {
                                       await new Promise(resolve => setTimeout(resolve, 2000)).then(() => {
                                           this.notification.state = 'recovered'
                                       });
                                    } catch (error) {
                                        console.log(error);
                                    }
                                },
                                'x-html'() {
                                    const recovering = '<?= $escaper->escapeJs(__('Recovering...')) ?>';
                                    const recover = '<?= $escaper->escapeJs(__('Recover')) ?>';
                                    const recovered = '<?= $escaper->escapeJs(__('Recovered')) ?>';
                                    const unrecoverable = '<?= $escaper->escapeJs(__('Failure')) ?>';

                                    return this.notification.state === 'recovering' ? recovering :
                                               this.notification.state === 'recovered' ? recovered :
                                                   this.notification.state === 'unrecoverable' ? unrecoverable :
                                                       recover;
                                },
                                'x-bind:class'() {
                                    return {
                                        'btn': true,
                                        'recovering': this.notification.state === 'recovering',
                                        'recovered': this.notification.state === 'recovered',
                                        'unrecoverable': this.notification.state === 'unrecoverable',
                                        'recoverable': this.notification.state === 'recoverable'
                                    };
                                },
                                'x-bind:disabled'() {
                                    return this.notification.state === 'recovering'
                                        || this.notification.state === 'recovered'
                                        || this.notification.state === 'unrecoverable';
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    function magewireNotifierBindings() {
        'use strict';

        return {
            'x-bind:class'() {
                return 'magewire-notifier';
            }
        };
    }

    <?php /* Register as Alpine component. */ ?>
    document.addEventListener('alpine:init', () => Alpine.data('magewireNotifier', magewireNotifier), { once: true });
    <?php /* Register Alpine component bindings (for optional usage). */ ?>
    document.addEventListener('alpine:init', () => Alpine.bind('magewireNotifierBindings', magewireNotifierBindings), { once: true });
</script>
<?php $script->end() ?>

